<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.2beta6 (1.42)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Data types</TITLE>
<META NAME="description" CONTENT="Data types">
<META NAME="keywords" CONTENT="schemetutorial">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta6">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="schemetutorial.css">

<LINK REL="next" HREF="node11.html">
<LINK REL="previous" HREF="node9.html">
<LINK REL="up" HREF="schemetutorial.html">
<LINK REL="next" HREF="node11.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<B> Next:</B> <A NAME="tex2html299"
  HREF="node11.html">Equivalence predicates</A>
<B> Previous:</B> <A NAME="tex2html289"
  HREF="node9.html">Imperative programming</A>
 &nbsp <B>  <A NAME="tex2html297"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html300"
  HREF="node10.html#SECTION001010000000000000000">Numbers</A>
<UL>
<LI><A NAME="tex2html301"
  HREF="node10.html#SECTION001011000000000000000">Operations on numbers</A>
</UL>
<LI><A NAME="tex2html302"
  HREF="node10.html#SECTION001020000000000000000">Booleans</A>
<UL>
<LI><A NAME="tex2html303"
  HREF="node10.html#SECTION001021000000000000000">Operations on booleans</A>
</UL>
<LI><A NAME="tex2html304"
  HREF="node10.html#SECTION001030000000000000000">Characters</A>
<UL>
<LI><A NAME="tex2html305"
  HREF="node10.html#SECTION001031000000000000000">Operations on characters</A>
</UL>
<LI><A NAME="tex2html306"
  HREF="node10.html#SECTION001040000000000000000">Symbols</A>
<UL>
<LI><A NAME="tex2html307"
  HREF="node10.html#SECTION001041000000000000000">Operations on symbols</A>
</UL>
<LI><A NAME="tex2html308"
  HREF="node10.html#SECTION001050000000000000000">Strings</A>
<UL>
<LI><A NAME="tex2html309"
  HREF="node10.html#SECTION001051000000000000000">Operations on strings</A>
</UL>
<LI><A NAME="tex2html310"
  HREF="node10.html#SECTION001060000000000000000">Pairs and lists</A>
<UL>
<LI><A NAME="tex2html311"
  HREF="node10.html#SECTION001061000000000000000">Pairs</A>
<LI><A NAME="tex2html312"
  HREF="node10.html#SECTION001062000000000000000">Lists</A>
<LI><A NAME="tex2html313"
  HREF="node10.html#SECTION001063000000000000000">Operations on pairs and lists</A>
</UL>
<LI><A NAME="tex2html314"
  HREF="node10.html#SECTION001070000000000000000">Vectors</A>
<UL>
<LI><A NAME="tex2html315"
  HREF="node10.html#SECTION001071000000000000000">Operations on vectors</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION001000000000000000000">
数据类型</A>
</H1>

<P>

<H1><A NAME="SECTION001010000000000000000">
数字</A>
</H1>

<P>
数字可以归类成不同的子类型，即：

<UL>
<LI>数
</LI>
<LI>复数
</LI>
<LI>实数
</LI>
<LI>有理数
</LI>
<LI>整数
</LI>
</UL>

<P>
For example, 2 is an integer, but it is also a rational, a real and a 
complex number.
<P>
比如，2 是一个整数，但是它同时也是一个有理数、实数以及一个复数。
<P>
Numbers can be represented both exactly and inexactly. A number is exact if
it was written as an exact constant or was derived from exact numbers using
only exact operations. Otherwise the number is inexact. The procedure
<TT>inexact-&gt;exact</TT> is an exception to this rule. 
<P>
数字可以表示为精确数或不精确数。如果一个数字书写为一个精确的常量，或者仅仅由精确的操作符产生，那么它就是精确数。否则就是不精确数。inexact->axact 过程是这个规则的一个例外。
<P>
A number may be expressed in binary, octal, decimal or hexadecimal by the
use of a radix prefix: <TT>#b</TT> for binary, <TT>#o</TT> for octal, 
<TT>#d</TT> for decimal and <TT>#x</TT> for hexadecimal. If no prefix is 
specified the radix is in decimal by default.
<P>
数字可以通过指定前缀来表示成二进制、八进制、十进制或者十六进制：#b 表示二进制，#o 表示八进制，#d 表示十进制，#x表示十六进制。如果没有指定前缀，那么它默认表示的是十进制数。
<P>

<H2><A NAME="SECTION001011000000000000000">
Operations on numbers</A>
</H2>
Scheme provides the following predicates for numbers:
<P>
Scheme 提供了下面的与数字有关的谓语：
<PRE>
(number? x)    ;;是数字吗？
(complex? x)   ;;是复数吗？
(real? x)      ;;是实数吗？
(rational? x)  ;;是有理数吗？
(integer? x)   ;;是整数吗？
(exact? x)     ;;是精确数吗？
(inexact? x)   ;;是非精确数吗？
(zero? x)      ;;是 0 吗？
(positive? x)  ;;是正数吗？
(negative? x)  ;;是负数吗？
(even? x)      ;;是偶数吗？
(odd? x)       ;;是奇数吗？
</PRE>

<P>
The names clearly imply what the procedures do, so we will only take a look
at some examples:
<P>
它们的名字很清楚地表明了该函数具体是用来做什么的：
<PRE>
&gt; (number? 5)
#t
&gt; (complex? 5)
#t
&gt; (zero? 0)
#t
&gt; (even? 0)
#t
&gt; (odd? 10)
#f
&gt; (exact? (* 5 5))
#t
&gt;(inexact? 3.1415)
#t
</PRE>

<P>
Arithmetic operations can be performed with the corresponding operators,
for example:
<P>
可以用对应的运算符来执行算术运算：
<PRE>
&gt; (+ 2 3 4)
9
&gt; (- 5 6)
-1
&gt; (* 1 2)
2
&gt; (/ 1 2)
1/2
&gt; (/ 1 2.0)
0.5
&gt; (+ (* 3 4) 2)
14
</PRE>

<P>
<TT>+</TT>, <TT>-</TT> and <TT>*</TT> are guaranteed to return exact results
if the arguments are exact. Some implementations regard division as an exact
operation if the arguments are exact. However, if division is performed on
exact numbers, which are very large, the computation might become very slow.
In that case one argument should be given as an inexact number, because it will
speed up the computation, but the result will no longer be exact. Unless
exact numbers are required this should not be a problem. Inexact numbers can
also be converted into exact numbers with the procedure 
<TT>inexact-&gt;exact</TT>.
<P>
+ - * 保证返回精确的结果，如果它们的参数是精确数的话。一些实现把除法（/）也看成是一个精确操作符，如果它的操作数也是精确数。然而，如果对一个非常巨大的精确数执行除法运算可能会非常地慢。在那种情况下，一个参数应该被作为一个非精确数，因为这样能加快计算，但是结果也将是非精确数。除非你需要一个精确的结果，否则这不会有什么大问题。非精确数可以通过 inexact->exact 转换成精确数。
<P>
There are also a couple of procedures which test whether their arguments are
equal, monotonically increasing or decreasing or monotonically nonincreasing
or decreasing. These are:
<P>
还有一些过程来测试它们的参数是否相等、递增或者递减。它们是：
<PRE>
(= x1 x2 ...)
(&gt; x1 x2 ...)
(&lt; x1 x2 ...)
(&gt;= x1 x2 ...)
(&lt;= x1 x2 ...)
</PRE>

<P>
They return either <TT>#t</TT> or <TT><TT>#f</TT></TT>. 
For example:
<P>
它们返回真或者假（#t or #f）：
<PRE>
&gt; (&lt; 3 4 5 6)
#t
&gt; (&lt;= 3 4 5 6)
#t
&gt; (&gt; 4 2 3 6)
#f
</PRE>

<P>
Note that <TT>=</TT> should only be used with exact numbers even if it
isn't  an error to use it on inexact ones<A NAME="tex2html15"
  HREF="footnode.html#foot1554"><SUP>8.1</SUP></A>. If used on inexact numbers, it might  return
something  unexpected because of the representation of inexact numbers
in the machine.
<P>
注意，相等谓语 = 仅仅用来比较精确数，但是如果你传递给它一个非精确数并不会引发错误。如果把 = 用于非精确数，因为非精确数在机器里面的表示，它可能会返回一些未预料的东西，
<P>
Scheme also provides various mathematical procedures:
<P>
Scheme 也提供了不同的数字函数：
<PRE>
(abs x)              ; 返回 x 的绝对值
(acos x)             ; 反余弦函数
(asin x)             ; 反正弦函数
(atan x)             ; 反正切函数
(atan x1 x2)         ; computes (angle (make-rectangular x2 x1))
(cos x)              ; 余弦函数
(exp x)              ; 自然常数 e 为底的指数函数
(expt n k)           ; 返回 n 的 k 次方
(log x)              ; 对数函数
(sqrt x)             ; 平方根函数
(sin x)              ; returns the sine of x
(tan x)              ; returns the tangent of x

(ceiling x)          ; 向上取整
(floor x)            ; 向下取整
(round x)            ; 四舍五入取整
(truncate x)         ; 截短取整

(denominator x)      ; 返回 x 的分母
(numerator x)        ; 返回 x 的分子

(gcd x1 x2 ...)      ; 求最大公约数
(lcm x1 x2 ...)      ; 求最小公约数

(max x1 x2 ...)      ; 返回参数中的最大值
(min x1 x2 ...)      ; 返回参数中的最小值

(quotient x1 x2)     ; 返回 x1 / x2 的商（整除法）
(modulo x1 x2)       ; 取模运算
(remainder x1 x2)    ; 取余运算，基本类似于取模运算，但是涉及到负数时，两者行为不太一样

(rationalize x1 x2)  ; returns the simplest rational number differing
                     ; from x1 no more than x2
</PRE>

<P>
For example, we can define <IMG
 WIDTH="14" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="pi"> by using the mathematical procedure 
<TT>acos</TT> in the following way:
<P>
例如，我们可以通过数字函数 acos 来定义 PI：
<PRE>
&gt; (define pi (acos -1))
&gt; pi
3.1415926535898
</PRE>

<P>
As can be seen from the list above, there are four procedures for rounding
numbers. 
<P>
如上面列出，总共有四种方法用来对一个数字取整
<P>
The procedure <TT>round</TT> rounds the argument to the nearest 
integer, but if the arguments is halfway between two integers, it rounds it
to the nearest even integer. For example:
<P>
round 四舍五入取整，但是如果正好位于两个整数之间（x.5）,它四舍五入到最接近的偶数。
<PRE>
&gt; (round pi)
3.0
&gt; (round 3.5)
4.0
&gt; (round 2.5) 
2.0
&gt; (round -2.5) ;;注意这里的结果不是3
-2.0
&gt; (round -3.4)
-3.0
&gt; (round -3.5)
-4.0
</PRE>

<P>
The procedure <TT>truncate</TT> chops the decimal part of the argument:
<P>
truncate 简单地丢弃小数部分：
<P>
<PRE>
&gt; (truncate pi)
3.0
&gt; (truncate 3.5)
3.0
&gt; (truncate -3.5)
-3.0
</PRE>

<P>
The procedure <TT>ceiling</TT> returns the smallest integer which is greater
than or equal to the argument, for example:
<P>
ceiling 返回大于或等于参数的最小整数（向上取整）
<P>
<PRE>
&gt; (ceiling pi)
4.0
&gt; (ceiling 3.5)
4.0
&gt; (ceiling -3.5) ;;注意负数的情况
-3.0
</PRE>

<P>
The procedure <TT>floor</TT> returns the largest integer which is less than
or equal to the argument, for example:
<P>
floor 过程返回小于或等于参数的最大整数（向下取整）
<PRE>
&gt; (floor pi)
3.0
&gt; (floor 3.5)
3.0
&gt; (floor -3.5) ;;同样要注意负数的情况
-4.0
</PRE>

<P>
Scheme also provides some trigonometric functions. Note that the argument is
in radians. For example:

<P>
<PRE>
&gt; (sin pi)
0.0
&gt; (cos pi)
-1.0
&gt; (- (tan pi) (/ (sin pi) (cos pi)))
0.0
&gt; (sqrt (ceiling (abs (cos pi))))
1.0
</PRE>

<P>
Some general procedures for complex numbers are also provided:
<PRE>
(make-rectangular x1 x2)   ; constructs a complex number in rectangular form
(make-polar x1 x2)         ; constructs a complex number in polar form
(real-part z)              ; returns the real part of the complex number z
(imag-part z)              ; returns the imaginary part of the complex number z
(magnitude z)              ; returns the magnitude of the complex number z
(angle z)                  ; returns the angle of the complex number z
</PRE>

<P>
For example, 
<PRE>
&gt; (define a (make-rectangular 3 4))
&gt; a
3+4i
&gt; (real-part a)
3
&gt; (imag-part a)
4
&gt; (magnitude a)
5
&gt; (angle (make-rectangular 3 4))
0.92729521800161
</PRE>

<P>
Scheme also provides the procedures <TT>inexact-&gt;exact</TT> and 
<TT>exact-&gt;inexact</TT> for converting inexact numbers into exact and vice
versa, for example:
<PRE>
&gt; (inexact-&gt;exact 5.0)
5
&gt; (exact-&gt;inexact 5)
5.0
</PRE>

<P>

<H1><A NAME="SECTION001020000000000000000">
布尔</A>
</H1>

<P>
The boolean objects are true and false and are written as <TT>#t</TT> and <TT>#f</TT>. 
All standard values in Scheme except <TT>#f</TT> count as true in conditional 
expressions.
<P>
布尔对象只有两个：真和假，分别写作 #t 和 #f。在 Scheme 条件表达式里，所有不是 #f 的值都视作为真。
<P>
Boolean constants evaluate to themselves and need not be quoted in
programs, e.g.
<P>
布尔常量是自求值的，在程序中不需要引用，即
<PRE>
&gt; #f
#f
&gt; #t
#t
</PRE>

<P>

<H2><A NAME="SECTION001021000000000000000">
Operations on booleans</A>
</H2>

<P>
Scheme provides a predicate <TT>boolean?</TT> with the following syntax:
<P>
Scheme 提供了一个谓语 boolean? 来测试对象是否是一个布尔值：
<PRE>
(boolean? x)
</PRE>

<P>
If <I>x</I> is either <TT>#t</TT> or <TT>#f</TT>, then <TT>#t</TT> is returned, otherwise <TT>#f</TT> is
returned.
<P>
如果 x 是 #t 或者 #f，它返回 #t, 否则返回 #f。
<P>
<PRE>
&gt; (boolean? #t) 
#t
&gt; (boolean? '())
#f
&gt; (boolean? (eq? 'x '(x y z)))
#t
</PRE>

<P>
Another procedure is <TT>not</TT>, which takes one argument and negates it:
<P>
另一个过程是 not，它接受一个参数，并且否定它：
<PRE>
&gt; (not #f)
#t
&gt; (not (= 5 4))
#t
</PRE>

<P>
Also the special forms <TT>and</TT> and <TT>or</TT> are used on boolean 
expressions.
<P>
特殊结构 and 和 or 也用于布尔表达式中。
<P>

<H1><A NAME="SECTION001030000000000000000">
字符</A>
</H1>

<P>
Characters are letters, numbers and other symbols on the computer
keyboard as well as some control characters such as <I>newline</I>
and
<I>space</I>. Characters are written using the notation 
<TT>#\&lt;char&gt;</TT> 
or <TT>#\&lt;character name&gt;</TT>. The former is case
sensitive whereas the  latter is not.
<P>
字符包括字母、数字、电脑键盘上的其它符号以及一些控制字符，比如 换行、空格。字符用 #\&lt;char&gt; 或者 #\&lt;character name&gt; 来表示。前者是大小写敏感的，而后者不是。
<P>
例如:
<PRE>
#\space
#\newline
#\s
</PRE>

<P>
Characters written in the #\ notation are self-evaluating.
<P>
用 #\ 标示的字符是自求值的。
<P>

<H2><A NAME="SECTION001031000000000000000">
Operations on characters</A>
</H2>

<P>
Most of the procedures for characters are predicates. If the procedure ignores
case it usually has <I>-ci</I> embedded in its name.
<P>
大多数与字符有关的内置过程是谓语。如果过程忽视大小写，那么它的名字中通常嵌入了 -ci。
<P>
Scheme provides the procedure <TT>char?</TT>, which has the following syntax:
<PRE>
(char? x)
</PRE>

<P>
If <I>x</I> is a character, the procedure returns <TT>#t</TT>, otherwise it 
returns <TT>#f</TT>. For example:
<P>
如果 x 是一个字符，过程返回 #t, 否则返回 #f, 例如：
<PRE>
&gt; (char? #\a)
#t
&gt; (char? 'a)   ;; 'a is a symbol, not a character
#f
&gt; (char? "a")  ;; "a" is a string, not a character
#f
&gt; (char? #\space)
#t
</PRE>

<P>
There are also procedures for finding out whether a given character comes
before or after another character in the alphabet. These are
<P>
有几个过程用于判断在字母表中一个字符是否位于另一个字符的前面或者后面。
<PRE>
(char=? ch1 ch2)     ; Is ch1 the same character as ch2?
(char&lt;? ch1 ch2)     ; Does ch1 come before ch2 in the alphabet?
(char&gt;? ch1 ch2)     ; Does ch1 come after ch2 in the alphabet?
(char&lt;=? ch1 ch2)    ; Does ch1 come before ch2 or are they both the same?
(char&gt;=? ch1 ch2)    ; Does ch1 come after ch2 or are they both the same?
(char-ci=? ch1 ch2)  ; The same as char=? but case-insensitive
(char-ci&lt;? ch1 ch2)  ; The same as char&lt;? but case-insensitive
(char-ci&gt;? ch1 ch2)  ; The same as char&gt;? but case-insensitive
(char-ci&lt;=? ch1 ch2) ; The same as char&lt;=? but case-insensitive
(char-ci&gt;=? ch1 ch2) ; The same as char&gt;=? but case-insensitive
</PRE>

<P>
Note that the lower case letters are in order, the upper case letters
are in order and the digits are in order and that all the upper case
letters precede  all the lower case or vice versa. Also note that all the 
digits either precede all the upper case letters or vice versa and that all the
digits either precede all the lower case letters or vice versa.

<P>
The following example shows the use of the procedures mentioned above, but
the result returned of the last expression is implementation-dependent:
<P>
下面的例子演示了上面提到的过程的用法。但是最后一个表达式的结果依赖于具体的实现：
<P>
<PRE>
&gt; (char=? #\a #\A)
#f
&gt; (char-ci=? #\a #\A)
#t
&gt; (char&lt;? #\a #\b)
#t
&gt; (char&gt;? #\a #\A)
#t
</PRE>

<P>
Scheme also provides procedures for finding out what kind of character is in
question, e.g. is it a digit, an alphabetic character...These procedures 
are:
<P>
Scheme 也提供了几个过程来判断字符的类型，即它是否是数字，或者字母...这些过程是：
<PRE>
(char-alphabetic? ch)  ;;ch 是字母吗
(char-numeric? ch)     ;;ch 是数字字符吗
(char-whitespace? ch)  ;;ch 是空白字符吗（空格、回车等都算空白字符）
(char-upper-case? ch)  ;;ch 是大写字母吗
(char-lower-case? ch)  ;;ch 是小写字母吗
</PRE>

<P>
Space, tab, line feed, form feed and carriage return are all regarded as 
whitespace characters.
<P>
空格、制表符、换行符、换页和回车都视为空白字符。
<P>
例如:
<PRE>
&gt; (char-alphabetic? #\a)
#t
&gt; (char-numeric? #\a)
#f
&gt; (char-numeric? #\2)
#t
&gt; (char-upper-case? #\A)
#t
&gt; (char-lower-case? #\A)
#f
</PRE>

<P>
There are also procedures for converting characters to integers representing 
the character (e.g. in the ASCII character set) and vice versa. 
These procedures are <TT>char-&gt;integer</TT> and <TT>integer-&gt;char</TT> and 
have the following syntax:
<P>
同样地，可以在字符和整数之间进行转换（ASCII码）。
<PRE>
(char-&gt;integer ch)
(integer-&gt;char n)
</PRE>

<P>
and can be used for example in the following way:
<PRE>
&gt; (char-&gt;integer #\3)
51
&gt; (char-&gt;integer #\a)
97
&gt; (integer-&gt;char 56)
#\8
&gt; (integer-&gt;char (char-&gt;integer #\b))
#\b
</PRE>

<P>
Note that the result returned by these procedures are implementation dependent.
<P>
注意，这些过程的结果依赖具体的实现。
<P>
Scheme also provides two procedures for converting upper case characters to
lower case and vice versa. They are the following:
<P>
Scheme 也提供了两个过程来转换大小写：
<PRE>
(char-upcase ch)   ;;转换成大写
(char-downcase ch) ;;转换成小写
</PRE>

<P>
For example:
<PRE>
&gt; (char-upcase #\a)
#\A
&gt; (char-downcase #\B)
#\b
&gt; (char-downcase #\b)
#\b
&gt; (char-downcase (char-upcase #\c))
#\c
</PRE>

<P>

<H1><A NAME="SECTION001040000000000000000">
符号</A>
</H1>

<P>
Symbols are objects, whose usefulness rest on the fact that two symbols are
equal if and only if their names are spelled the same way. 

<P>

<H2><A NAME="SECTION001041000000000000000">
Operations on symbols</A>
</H2>

<P>
Scheme provides a predicate <TT>symbol?</TT>, which takes one argument and
returns <TT>#t</TT> if the argument was a symbol and <TT>#f</TT> otherwise. For example,
<PRE>
&gt; (symbol? 'boo)
#t
&gt; (symbol? "boo")
#f
&gt; (symbol? (car '(a b c)))
#t
&gt; (symbol? '())
#f
</PRE>

<P>
There are also two procedures for converting a symbol to a string and vice 
versa, namely the procedures <TT>symbol-&gt;string</TT> and 
<TT>string-&gt;symbol</TT>. Note that the strings returned by
<TT>symbol-&gt;string</TT> are immutable.
<P>
有两个过程可以在符号和字符串之间互相转换
<P>
The procedures <TT>symbol-&gt;string</TT> and <TT>string-&gt;symbol</TT> work in the 
following way:
<PRE>
&gt; (symbol-&gt;string 'foo)
"foo"
&gt; (string-&gt;symbol "foo")
foo
&gt; (symbol-&gt;string (string-&gt;symbol "bar"))
"bar"
</PRE>

<P>

<H1><A NAME="SECTION001050000000000000000">
字符串</A>
</H1>

<P>
A string is written as a sequence of characters enclosed in double quotes. The
length of the string is the number of characters it contains. The first
character has the index value zero. Doublequotes can be written inside a
string by escaping them with a backslash.
<P>
一个字符串是用双引号包括起来的字符序列。字符串的长度是字符串所包含的字符的数量。第一个字符的索引值是 0。双引号本身可以是字符串的一部分，但是前面要加上反叙杠。
<P>
例如:
<PRE>
"This is a string and \"this is a string\" is also a string."
</PRE>

<P>

<H2><A NAME="SECTION001051000000000000000">
Operations on strings</A>
</H2>

<P>
Scheme provides a predicate <TT>string?</TT> for testing whether a given 
object is a string. It has the following syntax:
<PRE>
(string? str)
</PRE>

<P>
If <I>str</I> is a string, <TT>#t</TT> is returned, otherwise <TT>#f</TT> is returned.
For example,
<PRE>
&gt; (string? "boo")    
#t
&gt; (string? 'boo)    ; false, because 'boo is a symbol
#f
&gt; (string? 5)       ; false, because 5 is a number
#f
&gt; (string? "")
#t
</PRE>

<P>
Scheme also provides a variety of predicates for determining the 
lexicographic order of two strings.  If two strings differ in length in such 
a way that one is the prefix of the  other, the shorter  string is considered 
to be lexicographically less than the other. The procedures can be regarded as
extensions to strings of the corresponding orderings of characters.
<P>
Scheme 同样提供了一些变种过程用于判定两个字符串的字面序列。如果两个字符串长度不一致，较短的字符串比另一个要“小”。这些过程可以视为对应的字符函数的扩展。
<P>
The predicates are the following:
<PRE>
(string=? str1 str2)     ; Is str1 the same as str2?   
(string&lt;? str1 str2)     ; Is str1 lexicographically less than str2?
(string&gt;? str1 str2)     ; Is str2 lexicographically less than str1?
(string&lt;=? str1 str2)    ; Is str1 lexicographically less than or equal to str2?
(string&gt;=? str1 str2)    ; Is str2 lexicographically less than or equal to str1?
(string-ci=? str1 str2)  ; The same as string=? but case-insensitive
(string-ci&lt;? str1 str2)  ; The same as string&lt;? but case-insensitive 
(string-ci&gt;? str1 str2)  ; The same as string&gt;? but case-insensitive
(string-ci&lt;=? str1 str2) ; The same as string&lt;=? but case-insensitive
(string-ci&gt;=? str1 str2) ; The same as string&gt;=? but case-insensitive
</PRE>

<P>
The procedures containing <I>-ci</I> are case-insensitive. For example:
<PRE>
&gt; (string=? "foo" "FOO")      ; false, considered as different strings
#f
&gt; (string-ci=? "foo" "FOO")   ; true, the procedure is case-insensitive
#t
&gt; (string&lt;? "bar" "foo")      ; true, since bar comes before foo
#t
&gt; (string&lt;? "foobar" "foo")   ; false, foo is a prefix of and "less than" foobar
#f
</PRE>

<P>
Scheme also provides various procedures for creating and manipulating strings.
Strings can be created with the procedures <TT>make-string</TT> and 
<TT>string</TT>. They have the following syntax:
<P>
Scheme 同样提供了几个过程来自动或手动生成字符串。
<PRE>
(make-string n)      ;;n 指定字符串长度，由\u0000填充
(make-string n ch)   ;;n 指定字符串长度，由 ch 填充
(string ch1 ch2 ...) ;;将 ch1 ch2 ... 等单个字符组成一个字符串
</PRE>

<P>
It is also possible to create a string using doublequotes. Such strings are
so called string constants and cannot be changed later with procedures such
as <TT>string-set!</TT>. For example:
<P>
可以用双引号创建一个字符串，这样的字符串称作字符串常量，不能通过 string-set! 来改变其内容，例如：
<PRE>
&gt; "foo"
"foo"
</PRE>

<P>
Even if some implementations allow changing constant strings, you should not be
tempted to do so!
<P>
甚至有一些实现允许修改字符串常量，但是你不应该想这么干！
<P>
The procedure <TT>make-string</TT> takes either one or two arguments, where
<I>n</I> is the number of characters and <I>ch</I> represents the 
character. If <I>ch</I> is given, all characters in the string will be 
initialied to <I>ch</I>, otherwise the contents of the string are
implementation-dependent. The procedure <TT>string</TT> takes an arbitrary
number of characters and returns a string composed of the given characters.
For example:
<PRE>
&gt; (make-string 10 #\a)
"aaaaaaaaaa"
&gt; (string #\S #\c #\h #\e #\m #\e)
"Scheme"
</PRE>

<P>
The length of the string is the number of characters it is composed of. The
length of the empty string is 0. Scheme provides a procedure for computing the
length of the string, namely <TT>string-length</TT>, which takes one string as
an argument and returns an integer. For example:
<P>
字符串的长度是它包含的字符的数量。空字符串的长度是 0. Scheme 提供了一个过程来计算字符串的长度，名叫 string-length。它接受一个字符串作为参数，并返回一个整数。
<PRE>
&gt; (string-length "Scheme")
6
&gt; (string-length "This is a very clever sentence")
30
&gt; (string-length "")
0
</PRE>

<P>
Strings can also be concatenated using <TT>string-append</TT>, which takes
an arbitrary number of arguments and returns a newly allocated string 
composed of the characters of the strings given as arguments. For example:
<P>
字符串可以通过 string-append 过程连接在一起，它接受任意数量的参数，并返回一个包含所有参数的新字符串。
<PRE>
&gt; (string-append "foo" "bar" "foo" "bar" "foobar")
"foobarfoobarfoobar"
&gt; (string-append "Hello!" " " "My name is Torsten")
"Hello! My name is Torsten"
&gt; (string-append)
""
</PRE>

<P>
It is also possible to extract characters from a string using the 
<TT>string-ref</TT> procedure, which takes a string and an integer <I>n</I>
and returns the <I>n</I>th character. Note that the first character has the
index 0. For example:
<P>
同样地，可以通过 string-ref 过程从一个字符串中抽取出字符。它接受一个字符串和整数参数 n，并返回字符串中的第 n 个字符。记住，字符串中的字符是从 0 开始索引的。
<PRE>
&gt; (string-ref "foobar" 0)
#\f
&gt; (string-ref "foobar" 1)
#\o
&gt; (string-ref "foobar" 10)
string-ref: index 10 out of range [0, 5] for string: "foobar"
</PRE>

<P>
Scheme also provides a procedure <TT>substring</TT> with the following syntax:
<P>
Scheme 同样提供了一个过程 substring 来从一个字符串中提取出一个子字符串：
<PRE>
(substring str start end)
</PRE>

<P>
<I>str</I> must be a string and <I>start</I> and <I>end</I> are integers
such that 

<BR><!-- MATH
 $0~\le~start~\le~end~\le~$
 -->
<IMG
 WIDTH="168" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="0 <= start <= end <="> the length of the string.

<P>
For example:
<PRE>
&gt; (substring "foobar" 1 3)
"oo"
&gt; (substring "foobar" 0 0)
""
</PRE>

<P>
Scheme provides procedures for converting strings to lists of characters and 
vice versa. These
are <TT>string-&gt;list</TT> and <TT>list-&gt;string</TT> and work in the following
way:
<P>
可以在字符串及字符列表之间互相转换。
<PRE>
&gt; (string-&gt;list "foobar")
(#\f #\o #\o #\b #\a #\r)
&gt; (list-&gt;string '(#\f #\o #\o #\space #\b #\a #\r))
"foo bar"
&gt; (list-&gt;string '())
""
&gt; (string-&gt;list "")
()
</PRE>

<P>
Strings can be copied with the <TT>string-copy</TT> procedure, which takes
a string to be copied as argument and returns a newly allocated copy of the
argument. For example:
<P>
字符串可以通过 string-copy 来拷贝：
<PRE>
&gt; (string-copy "foobar")
"foobar"
&gt; (define a "foobar")
&gt; (define b (string-copy a))
&gt; b
"foobar"
</PRE>

<P>
There are two procedures causing side effects, namely <TT>string-set!</TT> and
<TT>string-fill!</TT>. The procedure <TT>string-set!</TT> has the following
syntax:
<P>
有两个字符串相关的函数具有副作用：
<PRE>
(string-set! str n ch)
</PRE>

<P>
and stores <I>ch</I> in element <I>n</I> of <I>str</I>. The value 
returned is unspecified. 
<P>
将 ch 存储进字符串 str 的第 n 个索引位置，返回值未定义。
<P>
For example:
<PRE>
&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; str
"foobar"
&gt; (string-set! str 2 #\d)
&gt; str
"fodbar"
&gt; (string-set! str 0 #\b)
&gt; str
"bodbar"
</PRE>

<P>
The procedures <TT>string-set!</TT> and <TT>string-copy</TT> are often used
together. We might, for example, want a copy of a given string, which we want
to change without changing the original string:
<P>
string-set! 和 string-copy 经常一起使用。也许我们想拷贝一个字符串，想修改这个拷贝的字符串但是又不想改变原始的字符串。
<PRE>
&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; (define foo (string-copy str))
&gt; str
"foobar"
&gt; foo
"foobar"
&gt; (string-set! foo 0 #\g)
&gt; str
"foobar"
&gt; foo
"goobar"
</PRE>

<P>
The procedure <TT>string-fill!</TT> has the following syntax:
<PRE>
(string-fill! str ch)
</PRE>

<P>
and stores <I>ch</I> in every element of <I>str</I> as a side effect. The
return value is unspecified. 
<P>
将 str 用 ch 来填充，长度不变，返回值未定义。
<P>
For example:
<PRE>
&gt; (define str (string #\f #\o #\o #\b #\a #\r))
&gt; (string-fill! str #\a)
&gt; str
"aaaaaa"
</PRE>

<P>

<H1><A NAME="SECTION001060000000000000000">
点对和列表</A>
</H1>

<P>

<H2><A NAME="SECTION001061000000000000000">
Pairs</A>
</H2>
A pair is a compound structure that can be manipulated and given a 
name. It is created using the procedure <TT>cons</TT>, which takes two
arguments and returns a compound data object containing the two arguments.
These can be extracted with the procedures <TT>car</TT> and <TT>cdr</TT>.
<P>
一个点对是一个复合数据结构。它同过程 cons 创建，cons 接受两个参数并且返回一个包含那两个参数的复合数据对象。其中所包含的两个参数可以通过 car 和 cdr 抽取出来。
<P>
例如:
<PRE>
(cons 1 2)
</PRE>

<P>
constructs a pair consisting of the two integers 1 and 2. The external
representation of this pair is <TT>(1 . 2)</TT>.  If we wish to give
our compound data object a name, we can use <TT>define</TT> as we are
used to:

<P>
<PRE>
(define a (cons 1 2))
</PRE>

<P>
If we wish to extract the first integer in the pair, we use <TT>car</TT>
<PRE>
&gt;(car a)
1
</PRE>

<P>
and if we wish to extract the second integer, we use <TT>cdr</TT>:

<P>
<PRE>
&gt;(cdr a)
2
</PRE>

<P>

<H2><A NAME="SECTION001062000000000000000"></A>
<A NAME="ls"></A>
<BR>
Lists
</H2>
Lists can be built using pairs. A list is denoted by a collection of items
enclosed in parentheses, e.g.
<PRE>
(2 4 6 8 10)
</PRE>

<P>
In other words, a list is a chain of pairs ending in the empty list.
If the chain of pairs does not end with the empty list, the list is said to
be improper. An improper list is not a list!

<P>
The empty list is denoted <TT>()</TT>. The list <TT>(2 4 6 8 10)</TT>
is the  same as <TT>(2 . (4 . (6 . (8 . (10 . ())))))</TT>. An
improper list can be  represented using dotted notations in the
following way:
<TT>(2 4 6 8 . 10)</TT>, which is equivalent to 
<TT>(2 . (4 . (6 . (8 . 10))))</TT>. 

<P>
Note that lists should be quoted when fed to the interpreter,
otherwise the  interpreter will try to apply the first item in the
list to the other items  in the list, e.g.
<PRE>
&gt; (2 4 6 8)
procedure application: expected procedure, given: 2; arguments were: 4 6 8
&gt; '(2 4 6 8)
(2 4 6 8)
</PRE>

<P>
Lists can be constructed using <TT>cons</TT> in the following way:
<PRE>
(cons 2 (cons 4 (cons 6 (cons 8 (cons 10 '())))))
</PRE>

<P>
Note that 
<PRE>
(cons 1 (cons 2 '()))
</PRE>

<P>
is a list, whereas
<PRE>
(cons 1 2)
</PRE>

<P>
is not. The latter is a pair. A list is constructed from pairs and is
consiedered a pair, but a pair is not in itself a list! The empty list is,
however, not a pair.

<P>
Lists can also be constructed using the procedure <TT>list</TT> as follows:
<PRE>
(list 2 4 6 8 10)
</PRE>

<P>
If we wish to take lists apart, we can use <TT>car</TT> and <TT>cdr</TT> and
combinations thereof. For example:
<PRE>
&gt;(car (list 2 4 6 8 10))
2
</PRE>

<P>
whereas  

<P>
<PRE>
&gt;(cdr (list 2 4 6 8 10))
(4 6 8 10)
</PRE>

<P>
The result of applying <TT>cdr</TT> to a list is always a list.

<P>
Let's say that we want to extract the second element in
the list. In order to accomplish this we can combine <TT>car</TT> and 
<TT>cdr</TT> in the following way:

<P>
<PRE>
&gt;(car (cdr (list 2 4 6 8 10)))
4
</PRE>

<P>
There is a shortening for combined <TT>car</TT>:s and <TT>cdr</TT>:s. The
same could be accomplished as follows:
<PRE>
&gt;(cadr (list 2 4 6 8 10))
4
</PRE>

<P>
<TT>car</TT>:s and <TT>cdr</TT>:s can be combined four times. Hence, the
following combinations exist:
<PRE>
(caar ls)        ; is the same as (car (car ls))
(cadr ls)        ; is the same as (car (cdr ls))
(cdar ls)        ; is the same as (cdr (car ls)) 
(cddr ls)        ; is the same as (cdr (cdr ls)) 
(caaar ls)       ; is the same as (car (car (car ls)))
(caadr ls)       ; is the same as (car (car (cdr ls))) 
(cadar ls)       ; is the same as (car (cdr (car ls))) 
(caddr ls)       ; is the same as (car (cdr (cdr ls))) 
(cdaar ls)       ; is the same as (cdr (car (car ls))) 
(cdadr ls)       ; is the same as (cdr (car (cdr ls)))
(cddar ls)       ; is the same as (cdr (cdr (car ls)))
(cdddr ls)       ; is the same as (cdr (cdr (cdr ls)))
(caaaar ls)      ; is the same as (car (car (car (car ls))))
(caaadr ls)      ; is the same as (car (car (car (cdr ls)))) 
(caadar ls)      ; is the same as (car (car (cdr (car ls))))
(caaddr ls)      ; is the same as (car (car (cdr (cdr ls))))
(cadaar ls)      ; is the same as (car (cdr (car (car ls)))) 
(cadadr ls)      ; is the same as (car (cdr (car (cdr ls))))
(caddar ls)      ; is the same as (car (cdr (cdr (car ls))))
(cadddr ls)      ; is the same as (car (cdr (cdr (cdr ls))))
(cdaaar ls)      ; is the same as (cdr (car (car (car ls))))
(cdaadr ls)      ; is the same as (cdr (car (car (cdr ls)))) 
(cdadar ls)      ; is the same as (cdr (car (cdr (car ls))))
(cdaddr ls)      ; is the same as (cdr (car (cdr (cdr ls))))
(cddaar ls)      ; is the same as (cdr (cdr (car (car ls))))
(cddadr ls)      ; is the same as (cdr (cdr (car (cdr ls))))
(cdddar ls)      ; is the same as (cdr (cdr (cdr (car ls))))
(cddddr ls)      ; is the same as (cdr (cdr (cdr (cdr ls))))
</PRE>

<P>
For example:
<PRE>
&gt;(caddr (list 2 4 6 8 10))
6
&gt;(car (cdr (cdr (list 2 4 6 8 10))))
6
</PRE>

<P>
These procedures can also be combined if the standards ones are insufficient.
For example:
<PRE>
&gt; (define ls '(((((((1 2) 3) 4) 5) 6) 7) 8))
&gt; (caaaar ls)
(((1 2) 3) 4)
&gt; (car (caaaar ls))
((1 2) 3)
&gt; (cdaar (caaaar ls))
(2)
</PRE>

<P>
Scheme also provides the procedures <TT>set-car!</TT> and <TT>set-cdr!</TT>
for explicitly changing the value of the <TT>car</TT> or <TT>cdr</TT> of a 
list. This is done as a side effect and the return value is unspecified.

<P>
<PRE>
&gt; (define ls (list 1 2 3 4 5))
&gt; ls
(1 2 3 4 5)
&gt; (set-car! ls 10)
&gt; ls
(10 2 3 4 5)
&gt; (set-cdr! ls '())
&gt; ls
(10)
</PRE>

<P>
Note that lists created in the following way cannot be changed using
<TT>set-car!</TT> or <TT>set-cdr!</TT>:
<PRE>
&gt; (define ls '(1 2 3 4 5))
</PRE>

<P>
This is because <I>ls</I> is now a list constant that cannot be changed. 
Don't be tempted to do it incorrectly even if the implementation allows it.

<P>
Care should be taken when using <TT>set-car!</TT> and <TT>set-cdr!</TT>. For
example: when using <TT>set-cdr!</TT>, we may run into situations in which the
object is a list at first, but after application of <TT>set-cdr!</TT> it is
not. 

<P>

<H2><A NAME="SECTION001063000000000000000"></A>
<A NAME="opl"></A>
<BR>
Operations on pairs and lists
</H2>
We have already seen both <TT>car</TT> and <TT>cdr</TT>, now we shall take
a look at some other procedures which operate on lists. 

<P>
The length of a list is the number of top-level items in it. Scheme provides a
procedure <TT>length</TT> for computing the length of the list, which is given
as an argument. For example:
<PRE>
&gt;(length (list 2 4 6 8 10))
5
</PRE>

<P>
The length of the empty list is 0.
<PRE>
&gt; (length '())
0
</PRE>

<P>
There are a couple of predicates for pairs and lists, namely 
<TT>pair?</TT>, <TT>list?</TT> and <TT>null?</TT>. They have the following
syntax:
<PRE>
(pair? x)
(list? x)
(null? x)
</PRE>

<P>
The predicate <TT>pair?</TT> returns <TT>#t</TT> if <I>x</I> is a pair, otherwise it
returns <TT>#f</TT>. The predicate <TT>list?</TT> returns <TT>#t</TT> if <I>x</I> is a 
proper list and  <TT>#f</TT> otherwise. The predicate <TT>null?</TT> returns <TT>#t</TT> if 
<I>x</I> is the empty list and <TT>#f</TT> otherwise. 

<P>
<PRE>
&gt; (pair? (list 1 2 3 4))
#t
&gt; (pair? (cons 1 2))
#t
&gt; (pair? '())
#f
&gt; (pair? (car '(1 2 3)))
#f
&gt; (pair? (cdr '(1 2 3)))
#t
&gt; (pair? (car '((1 2) 3 4)))
#t
&gt; (pair? (cdr '(1 2)))
#t
</PRE>

<P>
The first example is considered a pair, since a list is a chain of pairs 
ending in the empty list. The second example is naturally a pair, but the
third one, namely the empty list, is not a pair. Numbers are not pairs either,
so if the <TT>car</TT> of the list whose first item is not a pair or a list
is tested using <TT>pair?</TT>, then <TT>#f</TT> will be returned. If the 
first element, on the other hand, is a pair or a list,
then <TT>#t</TT> will be returned. One might wonder, why the procedure in the 
last example returns <TT>#t</TT> instead of <TT>#f</TT>. This is because 
<TT>(1&nbsp;2)</TT> is a list and lists always end with the empty list, so the 
<TT>cdr</TT> of <TT>(1 2)</TT> is not 2, but <TT>(2)</TT>!

<P>
<PRE>
&gt; (list? (list 1 2 3 4))
#t
&gt; (list? (cons 1 2))
#f
&gt; (list? (cons 1 (cons 2 '())))
#t
&gt; (list? '())
#t
&gt; (list? '(a . b))
#f
</PRE>

<P>
The first example is obviously a list, but  the second is not, since a pair is
not a list. Lists end in the empty list, so the third example is a list. Also
the empty list alone is a list. The last example yields false, because the
list '(a . b) is not a proper list.

<P>
The predicate <TT>null?</TT> can be used as follows: 
<PRE>
&gt; (null? '(1 2 3))
#f
&gt; (null? '())
#t
&gt; (null? #f)
#f
</PRE>

<P>
If we wish to address a given element in a list we might want to
use <TT>list-ref</TT>, which takes two arguments, a list <I>ls</I> and 
an integer <I>n</I> and returns the <I>n</I>:th item in <I>ls</I>. 
For example:
<PRE>
&gt;(list-ref '(1 2 3 4) 2)
3 
&gt; (list-ref '(1 2 3 4) 0)
1
&gt; (list-ref '(1 2 3 4) 5)
list-ref: index 5 too large for list: (1 2 3 4)
</PRE>

<P>
Note that the index of the first item is 0! It is illegal to try to reference
an item with an index number larger than or equal to the length of the list.

<P>
If we want to return the sublist of a given list by omitting the first 
<I>n</I> items, we may use the procedure <TT>list-tail</TT>, which takes
two arguments, a list and an integer <I>n</I> as follows:
<PRE>
&gt; (list-tail '(1 2 3 4 5) 2)
(3 4 5)
&gt; (list-tail '(1 2 3 4 5) 0)
(1 2 3 4 5)
&gt; (list-tail '(1 2 3 4 5) 5)
()
&gt; (list-tail '(1 2 3 4 5) 7)
list-tail: index 7 too large for list: (1 2 3 4 5)
</PRE>

<P>
As we can see, it is an error if <I>n</I> is larger than the length of the
list.

<P>
To reverse the order of items in a list we can use the procedure 
<TT>reverse</TT> as follows:
<PRE>
&gt;(reverse '(1 2 3 4))
(4 3 2 1)
&gt; (reverse '((1 2) (3 4) (5 6)))
((5 6) (3 4) (1 2))
</PRE>

<P>
Scheme also provides a procedure <TT>append</TT> for appending lists, which 
are given as arguments: 
<PRE>
&gt; (append '(1 2 3) '(4 5 6))
(1 2 3 4 5 6)
&gt; (append '() '(1))
(1)
&gt; (append '(1 2 (3 4)) '())
(1 2 (3 4))
&gt; (append '(1 2 3) '(4 5 6) '(7 8 9))
(1 2 3 4 5 6 7 8 9)
</PRE>

<P>
The resulting list is almost always newly allocated, but it shares structure
with the last argument. If the last argument is not a proper list, then 
applying <TT>append</TT> will result in an improper list:

<P>
<PRE>
&gt; (append '(1 2) 'b)
(1 2 . b)
&gt; (append '() 'c)
c
</PRE>

<P>
There are also a couple of procedures for finding out whether a given element
can be found in a list, namely <TT>memq</TT>,  <TT>memv</TT> and 
<TT>member</TT>. These are not considered to be predicates, because they
return useful values instead of merely <TT>#t</TT> or <TT>#f</TT>.
The syntax is as follows:
<PRE>
(memq x ls)
(memv x ls)
(member x ls)
</PRE>

<P>
The difference between them is that <TT>memq</TT> uses <TT>eq?</TT> to compare,
<TT>memv</TT> uses <TT>eqv?</TT> and <TT>member</TT> uses 
<TT>equal?</TT><A NAME="tex2html16"
  HREF="footnode.html#foot1555"><SUP>8.2</SUP></A>.
The usage and return values of these procedures can best be described with a
few examples:
<PRE>
&gt; (memq 'a '(a b c))
(a b c)
&gt; (memq 'b '(a b c))
(b c)
&gt; (memv 'a '(a b c))
(a b c)
&gt; (member 'a '(a b c))
(a b c)
&gt; (memq 'a '(b c d))
#f
&gt; (memv 'a '(b c d))
#f
&gt; (member 'a '(b c d))
#f
</PRE>

<P>
As we can see, the procedures return the same values for top-level items.
Note that <TT>#f</TT> is returned if the element cannot be found instead of the
empty list!

<P>
<PRE>
&gt; (memq '(2 3) '((2 3) 4))
#f
&gt; (memv '(2 3) '((2 3) 4))
#f
&gt; (member '(2 3) '((2 3) 4))
((2 3) 4)
</PRE>

<P>
The procedure <TT>member</TT>, which uses <TT>equal?</TT> to compare the
contents of the list, is the only one that returns <TT>#t</TT> because 
<TT>equal?</TT> checks if two objects have the same value (e.g. if two lists
contain the same items) as opposed to <TT>eq?</TT> and <TT>eqv?</TT> that
check if two objects refer to the same place. 

<P>
There are also three procedures for finding the first pair with a given car
field in an association list, namely <TT>assq</TT>,
<TT>assv</TT> and <TT>assoc</TT>. They have the following syntax:

<P>
<PRE>
(assq x als)
(assv x als)
(assoc x als)
</PRE>

<P>
An association list is a list of pairs, for 
example:&nbsp;<TT>((x 10)&nbsp;(y 20)&nbsp;(z 30))</TT>. Let's take a look at a few 
examples:
<PRE>
&gt; (define als '((x 10) (y 20) (x 30)))
&gt; (assq 'a als)
#f
&gt; (assq 'x als)
(x 10)
&gt; (assq 'y als)
(y 20)
&gt; (assv 'x als)
(x 10)
&gt; (assoc 'x als)
(x 10)
&gt; (assoc (list 'x) '(((x)) ((b)) ((c))))
((x))
</PRE>

<P>
The difference between <TT>assq</TT>, <TT>assv</TT> and <TT>assoc</TT> is that
<TT>assq</TT> uses <TT>eq?</TT> to compare, <TT>assv</TT> uses <TT>eqv?</TT>
and <TT>assoc</TT> uses <TT>equal?</TT>.

<P>
Another extremely useful procedure in Scheme is <TT>map</TT>, which
takes a procedure and an arbitrary number of lists as arguments and
returns a list. If one list is given as an argument, the procedure
will be applied to each element of the list. If two or more lists are
given as arguments, the procedure is applied to each
<I>n</I>th item of each list. The lists must all be of the same length.
The procedure must of course be applicable to the elements in the
list,  otherwise an error will occur. Let's say we want to add one to
each element in the list <TT>(1 2 3 4 5)</TT>. This can be done in the
following way:
<PRE>
&gt; (map (lambda (x) (+ x 1)) '(1 2 3 4 5))
(2 3 4 5 6)
</PRE> 

<P>
Let's say that we want to compute the factorial of each element in the list.
The easiest way is to first define a procedure for computing the factorial of
an integer and then feed the procedure to <TT>map</TT> as follows:
<PRE>
(define fact
  (lambda (n)	
    (if (= n 0)
        1
        (* n (fact (- n 1)))))

&gt; (map fact (list 1 2 3 4 5))
(1 2 6 24 120)
</PRE> 

<P>
Now we might want to raise the factorial of each element in the list to a
given power. This requires a function taking two arguments. So, how can we
accomplish our task? Let's start by defining a procedure for raising the
factorial of a number to a given power:

<PRE>
(define fact-expt
  (lambda (n e)
    (expt (fact n) e)))
</PRE>

<P>
In order to use the procedure we can use <TT>map</TT> and keep the value of
<I>e</I>, the second argument of <TT>fact-expt</TT>, constant in the
following way:

<P>
<PRE>
&gt; (map (lambda (x) (fact-expt x 1)) (list 1 2 3 4 5))
(1 2 6 24 120)

&gt; (map (lambda (x) (fact-expt x 2)) (list 1 2 3 4 5))
(1 4 36 576 14400)

&gt; (map (lambda (x) (fact-expt x 3)) (list 1 2 3 4 5))
(1 8 216 13824 1728000)
</PRE> 

<P>
Note that <TT>map</TT> only works on the top-level items of a list. 

<P>
If two or more lists are given as arguments to map, the procedure will be
applied to each <I>n</I>th element of the lists, e.g:
<PRE>
&gt; (map + '(1 2 3) '(1 2 3))
(2 4 6)
&gt; (map * '(1 2 3) '(1 2 3) '(1 2 3))
(1 8 27)
</PRE>

<P>
Another procedure resembling <TT>map</TT> but used only for its side effects
is <TT>for-each</TT>, which has the following syntax:
<PRE>
(for-each proc ls1 ls2 ...)
</PRE>

<P>
The difference between <TT>map</TT> and <TT>for-each</TT> is that the latter is
guaranteed to apply the procedure to the elements in the order they appear.
Also note that <TT>map</TT> returns a list, whereas the return value of  
<TT>for-each</TT> is unspecified.
Let's look at a quick example:
<PRE>
&gt; (for-each 
   (lambda (x) 
     (begin 
       (display x) 
       (newline))) 
   '(I am the greatest))
i
am
the
greatest
</PRE>

<P>
In fact, <TT>for-each</TT> is commonly used for input and output.

<P>
Sometimes we want to apply a procedure to a list using the items of the list
as arguments to the procedure. Scheme has a procedure <TT>apply</TT> for this
purpose. <TT>apply</TT> has the following syntax:
<PRE>
(apply proc arg1 ... args)
</PRE>

<P>
The argument <TT>proc</TT> must be a procedure and <I>args</I> must be a 
list. The other arguments may be of any type as long as the procedure given
is applicable. The usage of <TT>apply</TT> is best described with a few 
examples:
<PRE>
&gt;(apply + 1 2 '(3)) 
6
&gt; (apply + '(1 2 3))
6
&gt; (apply - 1 2 3 4 '())
-8
&gt; (apply * (map (lambda (x) (fact x)) '(1 2 3)))
12
</PRE>

<P>

<H1><A NAME="SECTION001070000000000000000">
Vectors</A>
</H1>

<P>
Vectors are data types that associate elements with an integer starting from
zero. The difference between vectors and lists are that vectors usually 
occupy less space than the corresponding list and the time required to access a
random element is constant. Most of the procedures operating on lists are
linear in time.

<P>
Vectors are represented as #(obj ...), for example:
<PRE>
#((2 4 6 8) 1  "Scheme")
</PRE>

<P>
The length of a vector is the number of elements it contains. The length of
the vector above is hence 3.

<P>

<H2><A NAME="SECTION001071000000000000000">
Operations on vectors</A>
</H2>

<P>
Scheme provides a predicate <TT>vector?</TT> for determining whether a given
object is a vector or not. For example:
<PRE>
&gt; (vector? '(1 2 3 4))
#f
&gt; (vector? '#(1 2 3 4))
#t
</PRE>

<P>
There is a variety of procedures for creating and manipulating vectors. 
Vectors can be created with the procedures <TT>vector</TT> and 
<TT>make-vector</TT>.
The procedure <TT>vector</TT> takes an arbitrary number of arguments and 
returns a newly allocated vector containing the arguments as elements, for
example:
<PRE>
&gt; (vector 'a 'b "foobar" '(1 2 3 4) '#(another vector))
#(a b "foobar" (1 2 3 4) #(another vector))
&gt; (vector)
#()
</PRE>

<P>
The procedure <TT>make-vector</TT> has the following syntax:
<PRE>
(make-vector n)
(make-vector n k)
</PRE>

<P>
If <I>k</I> is given, a newly allocated vector consisting of <I>n</I>
elements, which all are <I>k</I>, will be returned. Otherwise, the contents
of the vector returned will be unspecified. For example:
<PRE>
&gt; (make-vector 3)
#(0 0 0)
&gt; (make-vector 3 "foobar")
#("foobar" "foobar" "foobar")
</PRE>

<P>
The length of the vector is the number of elements in it. Scheme provides a
procedure <TT>vector-length</TT>, which takes a vector as argument and returns
the length of the vector as follows:
<PRE>
&gt; (vector-length '#(a b c d))
4
&gt; (vector-length '#(a b #(a b) '(a b)))
4
&gt; (vector-length '#())
0
</PRE>

<P>
To reference an item in the vector, you can use the procedure 
<TT>vector-ref</TT>, which takes a vector and an integer <I>n</I> as
arguments and returns the <I>n</I>:th element in the vector. Note that the
first element is indexed as 0.
<PRE>
&gt; (vector-ref '#(1 2 3 4) 2)
3
&gt; (vector-ref '#(1 2 3 4) 0)
1
</PRE>

<P>
Vectors can be converted to lists and vice versa with the procedures
<TT>vector-&gt;list</TT> and <TT>list-&gt;vector</TT>. For example:
<PRE>
&gt; (vector-&gt;list '#(1 2 3 4))
(1 2 3 4)
&gt; (list-&gt;vector '(1 2 3 4))
#(1 2 3 4)
</PRE>

<P>
Scheme provides a procedure <TT>vector-set!</TT>, which has the following
syntax:
<PRE>
(vector-set! vec n k)
</PRE>

<P>
and stores the object <I>k</I> in index <I>n</I> of the vector 
<I>vec</I>. The return value is unspecified. 

<P>
For example:
<PRE>
&gt; (define v (vector 'a 'b 'c 'd))
&gt; (vector-set! v 0 1)
&gt; v
#(1 b c d)
&gt; (vector-set! v 3 '(a list of elements))
&gt; v
#(1 b c (a list of elements))
</PRE>

<P>
Note that the procedure <TT>vector-set!</TT> cannot be used on vector 
constants. 

<P>
Another procedure causing side effects is <TT>vector-fill!</TT>, which has
the following syntax:
<PRE>
(vector-fill! vec k)
</PRE>

<P>
It stores <I>k</I> in every element of <I>vec</I>. The return value is
unspecified. For example:
<PRE>
&gt; (define v (vector 1 2 3 4))
&gt; v
#(1 2 3 4)
&gt; (vector-fill! v '(1 2))
#((1 2) (1 2) (1 2) (1 2))
</PRE>

<P>
The procedure  <TT>vector-fill!</TT> cannot be used on vector constants either.

<P>
Note that even if the implementation returns something useful, as it did in
our example above, procedures which are used for their side effects (such
as <TT>vector-fill!</TT>) should never be used for the values they might 
return. 

<P>
<HR>
<!--Navigation Panel-->
<B> Next:</B> <A NAME="tex2html299"
  HREF="node11.html">Equivalence predicates</A>
<B> Previous:</B> <A NAME="tex2html289"
  HREF="node9.html">Imperative programming</A>
 &nbsp <B>  <A NAME="tex2html297"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Timo Lilja
2001-09-11
</ADDRESS>
</BODY>
</HTML>
